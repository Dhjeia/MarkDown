//思路
// 1. 先对所有边按权重排序
// 2. 遍历所有边，如果当前边的两个顶点不属于同一个连通分量，则将该边加入最小生成树中，并将两个顶点所在的连通分量合并
// 3. 直到所有边都被加入最小生成树中，或者连通分量数减少到1时结束

#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <climits>  // 包含 INT_MAX 的定义


struct Edge {
    int a, b, value;
};

// 边的比较函数，用于排序
bool compareEdges(Edge e1, Edge e2) {
    return e1.value < e2.value;
}

void kruskal();  // 函数声明

using namespace std;

int point, edge;
int map[100][100] = {0};  // 声明为0，方便后续使用
bool connection[100] = {0};
Edge edges[100];

int findParent(int node) {
    if (connection[node] == 0)
        return node;
    return findParent(connection[node]);
}

void unionNodes(int a, int b) {
    int parentA = findParent(a);
    int parentB = findParent(b);
    if (parentA != parentB) {
        connection[parentA] = parentB;
    }
}

int main() {
    cin >> point >> edge;

    Edge edges[edge];
    for (int i = 0; i < edge; i++) {
        int a, b, value;
        cin >> a >> b >> value;
        edges[i].a = a;
        edges[i].b = b;
        edges[i].value = value;
    }

    // 输出原始图
    for (int i = 1; i <= point; i++) {
        for (int j = 1; j <= point; j++) {
            if (map[i][j] != INT16_MAX) {
                cout << map[i][j] << " ";
            } else {
                cout << "0 ";
            }
        }
        cout << endl;
    }

    // kruskal函数
    kruskal();

    return 0;
}

void kruskal() {
    // 对边进行排序
    sort(edge, edge + edge, compareEdges);  // 这里的edge是数组的大小，而不是指针

    int mst_weight = 0;  // 存储最小生成树的权值
    for (int i = 0; i < edge; i++) {
        int a = edges[i].a;
        int b = edges[i].b;
        int value = edges[i].value;

        if (findParent(a) != findParent(b)) {
            unionNodes(a, b);
            mst_weight += value;
            //cout << "边 (" << a << ", " << b << ") 加入最小生成树，权值：" << value << endl;
        }
    }
    cout << "最小生成树的总权值：" << mst_weight << endl;
}

/*
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
*/
